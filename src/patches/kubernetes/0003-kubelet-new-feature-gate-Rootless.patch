From 45f7874bbd53cf10eb62377916417ba4c9a832e6 Mon Sep 17 00:00:00 2001
From: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>
Date: Mon, 29 Jun 2020 15:10:05 +0900
Subject: [PATCH 3/4] kubelet: new feature gate: Rootless

The Rootless feature gate allows the systemd cgroup manager (v2) to use the user instance of systemd.
A container is executed in a cgroup like "/user.slice/user-1001.slice/user@1001.service/user.slice/cri-containerd-6938564e754ad86269a536ed19172af0eff5f7ff0a41eefc5b433a76f1f38f16.scope".

* Tested with containerd and crun.
* Requires the kubelet and the CRI runtime to be executed in USER+MNT+NET namespaces, mostly via RootlessKit.
* cgroupsPerQOS is currently unsupported.

Example kubelet config:
```yaml
kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
...
featureGates:
  Rootless: true
rootless: true
cgroupDriver: systemd
cgroupsPerQOS: false
```

Signed-off-by: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>
---
 cmd/kubelet/app/server.go                     |  1 +
 pkg/features/kube_features.go                 |  7 +++
 pkg/kubelet/apis/config/fuzzer/fuzzer.go      |  1 +
 pkg/kubelet/apis/config/helpers_test.go       |  1 +
 pkg/kubelet/apis/config/types.go              |  4 ++
 .../config/v1beta1/zz_generated.conversion.go |  2 +
 pkg/kubelet/cm/cgroup_manager_linux.go        | 51 ++++++++++++-------
 pkg/kubelet/cm/container_manager.go           |  1 +
 pkg/kubelet/cm/container_manager_linux.go     | 19 ++++++-
 pkg/kubelet/cm/pod_container_manager_linux.go |  7 ++-
 .../cm/pod_container_manager_linux_test.go    |  6 ++-
 .../k8s.io/kubelet/config/v1beta1/types.go    |  6 +++
 test/e2e_node/node_container_manager_test.go  |  5 +-
 13 files changed, 88 insertions(+), 23 deletions(-)

diff --git a/cmd/kubelet/app/server.go b/cmd/kubelet/app/server.go
index f920f65c004..9e35d23f607 100644
--- a/cmd/kubelet/app/server.go
+++ b/cmd/kubelet/app/server.go
@@ -739,6 +739,7 @@ func run(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Depend
 				EnforceCPULimits:                      s.CPUCFSQuota,
 				CPUCFSQuotaPeriod:                     s.CPUCFSQuotaPeriod.Duration,
 				ExperimentalTopologyManagerPolicy:     s.TopologyManagerPolicy,
+				Rootless:                              s.Rootless,
 			},
 			s.FailSwapOn,
 			devicePluginEnabled,
diff --git a/pkg/features/kube_features.go b/pkg/features/kube_features.go
index 165040aa182..ecd448010c4 100644
--- a/pkg/features/kube_features.go
+++ b/pkg/features/kube_features.go
@@ -651,6 +651,12 @@ const (
 	// Add support for the HPA to scale based on metrics from individual containers
 	// in target pods
 	HPAContainerMetrics featuregate.Feature = "HPAContainerMetrics"
+
+	// owner: @AkihiroSuda
+	// alpha: v1.XX
+	//
+	// Enable rootless mode.
+	Rootless featuregate.Feature = "Rootless"
 )
 
 func init() {
@@ -749,6 +755,7 @@ var defaultKubernetesFeatureGates = map[featuregate.Feature]featuregate.FeatureS
 	WinDSR:                                         {Default: false, PreRelease: featuregate.Alpha},
 	DisableAcceleratorUsageMetrics:                 {Default: true, PreRelease: featuregate.Beta},
 	HPAContainerMetrics:                            {Default: false, PreRelease: featuregate.Alpha},
+	Rootless:                                       {Default: false, PreRelease: featuregate.Alpha},
 
 	// inherited features from generic apiserver, relisted here to get a conflict if it is changed
 	// unintentionally on either side:
diff --git a/pkg/kubelet/apis/config/fuzzer/fuzzer.go b/pkg/kubelet/apis/config/fuzzer/fuzzer.go
index a1312f1a421..2f389e38d14 100644
--- a/pkg/kubelet/apis/config/fuzzer/fuzzer.go
+++ b/pkg/kubelet/apis/config/fuzzer/fuzzer.go
@@ -60,6 +60,7 @@ func Funcs(codecs runtimeserializer.CodecFactory) []interface{} {
 			obj.ImageGCHighThresholdPercent = 85
 			obj.ImageGCLowThresholdPercent = 80
 			obj.KernelMemcgNotification = false
+			obj.Rootless = false
 			obj.MaxOpenFiles = 1000000
 			obj.MaxPods = 110
 			obj.PodPidsLimit = -1
diff --git a/pkg/kubelet/apis/config/helpers_test.go b/pkg/kubelet/apis/config/helpers_test.go
index c75d4d289d3..0c492c57930 100644
--- a/pkg/kubelet/apis/config/helpers_test.go
+++ b/pkg/kubelet/apis/config/helpers_test.go
@@ -219,6 +219,7 @@ var (
 		"RegistryBurst",
 		"RegistryPullQPS",
 		"ReservedSystemCPUs",
+		"Rootless",
 		"RuntimeRequestTimeout.Duration",
 		"RunOnce",
 		"SerializeImagePulls",
diff --git a/pkg/kubelet/apis/config/types.go b/pkg/kubelet/apis/config/types.go
index a7e2d5e1b23..e77dc3e7d6c 100644
--- a/pkg/kubelet/apis/config/types.go
+++ b/pkg/kubelet/apis/config/types.go
@@ -325,6 +325,10 @@ type KubeletConfiguration struct {
 	// kernelMemcgNotification if enabled, the kubelet will integrate with the kernel memcg
 	// notification to determine if memory eviction thresholds are crossed rather than polling.
 	KernelMemcgNotification bool
+	// Rootless enables the rootless cgroup manager.
+	// Requires cgroup v2 and systemd.
+	// Requires the Rootless feature gate to be enabled.
+	Rootless bool
 
 	/* the following fields are meant for Node Allocatable */
 
diff --git a/pkg/kubelet/apis/config/v1beta1/zz_generated.conversion.go b/pkg/kubelet/apis/config/v1beta1/zz_generated.conversion.go
index e0b7608745b..590bf57c8bd 100644
--- a/pkg/kubelet/apis/config/v1beta1/zz_generated.conversion.go
+++ b/pkg/kubelet/apis/config/v1beta1/zz_generated.conversion.go
@@ -332,6 +332,7 @@ func autoConvert_v1beta1_KubeletConfiguration_To_config_KubeletConfiguration(in
 		return err
 	}
 	out.ConfigMapAndSecretChangeDetectionStrategy = config.ResourceChangeDetectionStrategy(in.ConfigMapAndSecretChangeDetectionStrategy)
+	out.Rootless = in.Rootless
 	out.SystemReserved = *(*map[string]string)(unsafe.Pointer(&in.SystemReserved))
 	out.KubeReserved = *(*map[string]string)(unsafe.Pointer(&in.KubeReserved))
 	out.ReservedSystemCPUs = in.ReservedSystemCPUs
@@ -486,6 +487,7 @@ func autoConvert_config_KubeletConfiguration_To_v1beta1_KubeletConfiguration(in
 	out.ConfigMapAndSecretChangeDetectionStrategy = v1beta1.ResourceChangeDetectionStrategy(in.ConfigMapAndSecretChangeDetectionStrategy)
 	out.AllowedUnsafeSysctls = *(*[]string)(unsafe.Pointer(&in.AllowedUnsafeSysctls))
 	out.KernelMemcgNotification = in.KernelMemcgNotification
+	out.Rootless = in.Rootless
 	out.SystemReserved = *(*map[string]string)(unsafe.Pointer(&in.SystemReserved))
 	out.KubeReserved = *(*map[string]string)(unsafe.Pointer(&in.KubeReserved))
 	out.SystemReservedCgroup = in.SystemReservedCgroup
diff --git a/pkg/kubelet/cm/cgroup_manager_linux.go b/pkg/kubelet/cm/cgroup_manager_linux.go
index b99f20e870a..845ffffce50 100644
--- a/pkg/kubelet/cm/cgroup_manager_linux.go
+++ b/pkg/kubelet/cm/cgroup_manager_linux.go
@@ -36,6 +36,8 @@ import (
 
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
 	"k8s.io/apimachinery/pkg/util/sets"
+	utilfeature "k8s.io/apiserver/pkg/util/feature"
+	kubefeatures "k8s.io/kubernetes/pkg/features"
 	cmutil "k8s.io/kubernetes/pkg/kubelet/cm/util"
 	"k8s.io/kubernetes/pkg/kubelet/metrics"
 )
@@ -131,18 +133,22 @@ func IsSystemdStyleName(name string) bool {
 type libcontainerAdapter struct {
 	// cgroupManagerType defines how to interface with libcontainer
 	cgroupManagerType libcontainerCgroupManagerType
+	rootless          bool
 }
 
 // newLibcontainerAdapter returns a configured libcontainerAdapter for specified manager.
 // it does any initialization required by that manager to function.
-func newLibcontainerAdapter(cgroupManagerType libcontainerCgroupManagerType) *libcontainerAdapter {
-	return &libcontainerAdapter{cgroupManagerType: cgroupManagerType}
+func newLibcontainerAdapter(cgroupManagerType libcontainerCgroupManagerType, rootless bool) *libcontainerAdapter {
+	return &libcontainerAdapter{cgroupManagerType: cgroupManagerType, rootless: rootless}
 }
 
 // newManager returns an implementation of cgroups.Manager
 func (l *libcontainerAdapter) newManager(cgroups *libcontainerconfigs.Cgroup, paths map[string]string) (libcontainercgroups.Manager, error) {
 	switch l.cgroupManagerType {
 	case libcontainerCgroupfs:
+		if l.rootless {
+			return nil, fmt.Errorf("cgroup manager %v does not support rootless", l.cgroupManagerType)
+		}
 		if libcontainercgroups.IsCgroup2UnifiedMode() {
 			return cgroupfs2.NewManager(cgroups, paths["memory"], false)
 		}
@@ -153,7 +159,10 @@ func (l *libcontainerAdapter) newManager(cgroups *libcontainerconfigs.Cgroup, pa
 			panic("systemd cgroup manager not available")
 		}
 		if libcontainercgroups.IsCgroup2UnifiedMode() {
-			return cgroupsystemd.NewUnifiedManager(cgroups, paths["memory"], false), nil
+			return cgroupsystemd.NewUnifiedManager(cgroups, paths["memory"], l.rootless), nil
+		}
+		if l.rootless {
+			return nil, fmt.Errorf("cgroup manager %v requires cgroup v2 for rootless", l.cgroupManagerType)
 		}
 		return cgroupsystemd.NewLegacyManager(cgroups, paths), nil
 	}
@@ -187,15 +196,18 @@ type cgroupManagerImpl struct {
 var _ CgroupManager = &cgroupManagerImpl{}
 
 // NewCgroupManager is a factory method that returns a CgroupManager
-func NewCgroupManager(cs *CgroupSubsystems, cgroupDriver string) CgroupManager {
+func NewCgroupManager(cs *CgroupSubsystems, cgroupDriver string, rootless bool) (CgroupManager, error) {
 	managerType := libcontainerCgroupfs
 	if cgroupDriver == string(libcontainerSystemd) {
 		managerType = libcontainerSystemd
 	}
+	if rootless && !utilfeature.DefaultFeatureGate.Enabled(kubefeatures.Rootless) {
+		return nil, fmt.Errorf("rootless requires Rootless feature gate")
+	}
 	return &cgroupManagerImpl{
 		subsystems: cs,
-		adapter:    newLibcontainerAdapter(managerType),
-	}
+		adapter:    newLibcontainerAdapter(managerType, rootless),
+	}, nil
 }
 
 // Name converts the cgroup to the driver specific value in cgroupfs form.
@@ -464,18 +476,20 @@ func propagateControllers(path string) error {
 }
 
 // setResourcesV2 sets cgroup resource limits on cgroup v2
-func setResourcesV2(cgroupConfig *libcontainerconfigs.Cgroup) error {
+func setResourcesV2(cgroupConfig *libcontainerconfigs.Cgroup, rootless bool) error {
 	if err := propagateControllers(cgroupConfig.Path); err != nil {
 		return err
 	}
-	cgroupConfig.Resources.Devices = []*libcontainerconfigs.DeviceRule{
-		{
-			Type:        'a',
-			Permissions: "rwm",
-			Allow:       true,
-			Minor:       libcontainerconfigs.Wildcard,
-			Major:       libcontainerconfigs.Wildcard,
-		},
+	if !rootless {
+		cgroupConfig.Resources.Devices = []*libcontainerconfigs.DeviceRule{
+			{
+				Type:        'a',
+				Permissions: "rwm",
+				Allow:       true,
+				Minor:       libcontainerconfigs.Wildcard,
+				Major:       libcontainerconfigs.Wildcard,
+			},
+		}
 	}
 	cgroupConfig.Resources.SkipDevices = true
 
@@ -487,7 +501,7 @@ func setResourcesV2(cgroupConfig *libcontainerconfigs.Cgroup) error {
 		klog.V(6).Infof("Optional subsystem not supported: hugetlb")
 	}
 
-	manager, err := cgroupfs2.NewManager(cgroupConfig, filepath.Join(cmutil.CgroupRoot, cgroupConfig.Path), false)
+	manager, err := cgroupfs2.NewManager(cgroupConfig, filepath.Join(cmutil.CgroupRoot, cgroupConfig.Path), rootless)
 	if err != nil {
 		return fmt.Errorf("failed to create cgroup v2 manager: %v", err)
 	}
@@ -593,7 +607,8 @@ func (m *cgroupManagerImpl) Update(cgroupConfig *CgroupConfig) error {
 	}
 
 	if unified {
-		if err := setResourcesV2(libcontainerCgroupConfig); err != nil {
+		rootless := m.adapter.rootless
+		if err := setResourcesV2(libcontainerCgroupConfig, rootless); err != nil {
 			return fmt.Errorf("failed to set resources for cgroup %v: %v", cgroupConfig.Name, err)
 		}
 	} else {
@@ -749,7 +764,7 @@ func (m *cgroupManagerImpl) GetResourceStats(name CgroupName) (*ResourceStats, e
 	var stats *libcontainercgroups.Stats
 	if libcontainercgroups.IsCgroup2UnifiedMode() {
 		cgroupPath := m.buildCgroupUnifiedPath(name)
-		manager, err := cgroupfs2.NewManager(nil, cgroupPath, false)
+		manager, err := cgroupfs2.NewManager(nil, cgroupPath, m.adapter.rootless)
 		if err != nil {
 			return nil, fmt.Errorf("failed to create cgroup v2 manager: %v", err)
 		}
diff --git a/pkg/kubelet/cm/container_manager.go b/pkg/kubelet/cm/container_manager.go
index 83c150cbec1..8f8a27a9dd0 100644
--- a/pkg/kubelet/cm/container_manager.go
+++ b/pkg/kubelet/cm/container_manager.go
@@ -135,6 +135,7 @@ type NodeConfig struct {
 	EnforceCPULimits                      bool
 	CPUCFSQuotaPeriod                     time.Duration
 	ExperimentalTopologyManagerPolicy     string
+	Rootless                              bool
 }
 
 type NodeAllocatableConfig struct {
diff --git a/pkg/kubelet/cm/container_manager_linux.go b/pkg/kubelet/cm/container_manager_linux.go
index 4d889870bf9..b27dab5583b 100644
--- a/pkg/kubelet/cm/container_manager_linux.go
+++ b/pkg/kubelet/cm/container_manager_linux.go
@@ -257,9 +257,17 @@ func NewContainerManager(mountUtil mount.Interface, cadvisorInterface cadvisor.I
 
 	// Turn CgroupRoot from a string (in cgroupfs path format) to internal CgroupName
 	cgroupRoot := ParseCgroupfsToCgroupName(nodeConfig.CgroupRoot)
-	cgroupManager := NewCgroupManager(subsystems, nodeConfig.CgroupDriver)
+	cgroupManager, err := NewCgroupManager(subsystems, nodeConfig.CgroupDriver, nodeConfig.Rootless)
+	if err != nil {
+		return nil, err
+	}
 	// Check if Cgroup-root actually exists on the node
 	if nodeConfig.CgroupsPerQOS {
+		if nodeConfig.Rootless {
+			// TODO(AkihiroSuda): support rootless
+			return nil, fmt.Errorf("invalid configuration: cgroups-per-qos is not supported for rootless")
+		}
+
 		// this does default to / when enabled, but this tests against regressions.
 		if nodeConfig.CgroupRoot == "" {
 			return nil, fmt.Errorf("invalid configuration: cgroups-per-qos was specified and cgroup-root was not specified. To enable the QoS cgroup hierarchy you need to specify a valid cgroup-root")
@@ -359,7 +367,8 @@ func (cm *containerManagerImpl) NewPodContainerManager() PodContainerManager {
 		}
 	}
 	return &podContainerManagerNoop{
-		cgroupRoot: cm.cgroupRoot,
+		cgroupRoot:      cm.cgroupRoot,
+		rootlessSystemd: cm.NodeConfig.Rootless && cm.NodeConfig.CgroupDriver == "systemd",
 	}
 }
 
@@ -502,6 +511,9 @@ func (cm *containerManagerImpl) setupNode(activePods ActivePodsFunc) error {
 		if cm.SystemCgroupsName == "/" {
 			return fmt.Errorf("system container cannot be root (\"/\")")
 		}
+		if cm.Rootless {
+			return fmt.Errorf("rootless does not support SystemCgroupsName")
+		}
 		cont, err := newSystemCgroups(cm.SystemCgroupsName)
 		if err != nil {
 			return err
@@ -513,6 +525,9 @@ func (cm *containerManagerImpl) setupNode(activePods ActivePodsFunc) error {
 	}
 
 	if cm.KubeletCgroupsName != "" {
+		if cm.Rootless {
+			return fmt.Errorf("rootless does not support KubeletCgroupsName")
+		}
 		cont, err := newSystemCgroups(cm.KubeletCgroupsName)
 		if err != nil {
 			return err
diff --git a/pkg/kubelet/cm/pod_container_manager_linux.go b/pkg/kubelet/cm/pod_container_manager_linux.go
index b9fa3e05cde..2f5fc0ff01a 100644
--- a/pkg/kubelet/cm/pod_container_manager_linux.go
+++ b/pkg/kubelet/cm/pod_container_manager_linux.go
@@ -291,7 +291,8 @@ func (m *podContainerManagerImpl) GetAllPodsFromCgroups() (map[types.UID]CgroupN
 // enabled, so Exists() returns true always as the cgroupRoot
 // is expected to always exist.
 type podContainerManagerNoop struct {
-	cgroupRoot CgroupName
+	cgroupRoot      CgroupName
+	rootlessSystemd bool
 }
 
 // Make sure that podContainerManagerStub implements the PodContainerManager interface
@@ -306,6 +307,10 @@ func (m *podContainerManagerNoop) EnsureExists(_ *v1.Pod) error {
 }
 
 func (m *podContainerManagerNoop) GetPodContainerName(_ *v1.Pod) (CgroupName, string) {
+	if m.rootlessSystemd {
+		// "user.slice" is set to PodConfig.Linux.CgroupParent
+		return m.cgroupRoot, "user.slice"
+	}
 	return m.cgroupRoot, ""
 }
 
diff --git a/pkg/kubelet/cm/pod_container_manager_linux_test.go b/pkg/kubelet/cm/pod_container_manager_linux_test.go
index 62c9f203a00..db4ed280da1 100644
--- a/pkg/kubelet/cm/pod_container_manager_linux_test.go
+++ b/pkg/kubelet/cm/pod_container_manager_linux_test.go
@@ -100,8 +100,12 @@ func TestIsCgroupPod(t *testing.T) {
 		},
 	}
 	for _, cgroupDriver := range []string{"cgroupfs", "systemd"} {
+		cm, err := NewCgroupManager(nil, cgroupDriver, false)
+		if err != nil {
+			t.Fatal(err)
+		}
 		pcm := &podContainerManagerImpl{
-			cgroupManager:     NewCgroupManager(nil, cgroupDriver),
+			cgroupManager:     cm,
 			enforceCPULimits:  true,
 			qosContainersInfo: qosContainersInfo,
 		}
diff --git a/staging/src/k8s.io/kubelet/config/v1beta1/types.go b/staging/src/k8s.io/kubelet/config/v1beta1/types.go
index d298f3c4b21..f1c24ad1ff9 100644
--- a/staging/src/k8s.io/kubelet/config/v1beta1/types.go
+++ b/staging/src/k8s.io/kubelet/config/v1beta1/types.go
@@ -702,6 +702,12 @@ type KubeletConfiguration struct {
 	// Default: "Watch"
 	// +optional
 	ConfigMapAndSecretChangeDetectionStrategy ResourceChangeDetectionStrategy `json:"configMapAndSecretChangeDetectionStrategy,omitempty"`
+	// Rootless enables the rootless cgroup manager.
+	// Requires cgroup v2 and systemd.
+	// Requires the Rootless feature gate to be enabled.
+	// Default: false
+	// +optional
+	Rootless bool `json:"rootless,omitempty"`
 
 	/* the following fields are meant for Node Allocatable */
 
diff --git a/test/e2e_node/node_container_manager_test.go b/test/e2e_node/node_container_manager_test.go
index d128cecaee6..313a2e6b6a0 100644
--- a/test/e2e_node/node_container_manager_test.go
+++ b/test/e2e_node/node_container_manager_test.go
@@ -167,7 +167,10 @@ func runTest(f *framework.Framework) error {
 	}
 
 	// Create a cgroup manager object for manipulating cgroups.
-	cgroupManager := cm.NewCgroupManager(subsystems, oldCfg.CgroupDriver)
+	cgroupManager, err := cm.NewCgroupManager(subsystems, oldCfg.CgroupDriver, false)
+	if err != nil {
+		return err
+	}
 
 	defer destroyTemporaryCgroupsForReservation(cgroupManager)
 	defer func() {
-- 
2.27.0

